name: Build and Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  verify-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Verify version consistency
        run: |
          TAG_VERSION=${GITHUB_REF#refs/tags/v}
          CONFIG_VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)

          echo "üîç ÁâàÊú¨È™åËØÅ:"
          echo "  Git Tag: v$TAG_VERSION"
          echo "  tauri.conf.json: $CONFIG_VERSION"

          if [ "$TAG_VERSION" != "$CONFIG_VERSION" ]; then
            echo "‚ùå ÁâàÊú¨Âè∑‰∏çÂåπÈÖçÔºÅ"
            echo "   ËØ∑Á°Æ‰øù Git tag Âíå tauri.conf.json ‰∏≠ÁöÑÁâàÊú¨Âè∑‰∏ÄËá¥"
            exit 1
          fi
          echo "‚úÖ ÁâàÊú¨Âè∑È™åËØÅÈÄöËøáÔºÅ"

  create-release:
    needs: verify-version
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
      release_upload_url: ${{ steps.create-release.outputs.upload_url }}

    steps:
      - uses: actions/checkout@v4

      - name: Get or create release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const tag = '${{ github.ref_name }}';

            // Try to get existing release
            try {
              const { data } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tag
              });
              console.log(`Found existing release: ${data.id}`);
              return data.id;
            } catch (error) {
              if (error.status === 404) {
                // Create new release if not exists
                const { data } = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: tag,
                  name: `Release ${tag}`,
                  body: 'See the assets to download and install this version.',
                  draft: true,
                  prerelease: false
                });
                console.log(`Created new release: ${data.id}`);
                return data.id;
              }
              throw error;
            }

  build-macos:
    needs: [verify-version, create-release]
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependencies
        run: npm ci

      - name: Build Tauri app
        run: npm run tauri:build

      - name: Find and upload DMG
        shell: bash
        run: |
          DMG_FILE=$(find src-tauri/target/release/bundle/dmg -name "*.dmg" -type f | head -n 1)
          if [ -f "$DMG_FILE" ]; then
            echo "Found DMG: $DMG_FILE"
            ARCH=$(echo "$DMG_FILE" | grep -o 'aarch64\|x86_64' || echo "aarch64")
            gh release upload ${{ github.ref_name }} "$DMG_FILE" --clobber

            # ‰∏ä‰º† macOS ‰øÆÂ§çËÑöÊú¨Âíå‰ΩøÁî®ËØ¥Êòé
            echo "Uploading macOS helper files..."
            gh release upload ${{ github.ref_name }} \
              "src-tauri/resources/fix-macos.command" \
              "src-tauri/resources/README-macOS.txt" \
              --clobber
          else
            echo "No DMG file found"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-windows:
    needs: [verify-version, create-release]
    runs-on: windows-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependencies
        run: npm ci

      - name: Build Tauri app
        run: npm run tauri:build

      - name: List build output
        shell: bash
        run: |
          echo "=== Checking build output directories ==="
          echo "MSI directory:"
          ls -la src-tauri/target/release/bundle/msi/ 2>/dev/null || echo "MSI directory not found"
          echo ""
          echo "NSIS directory:"
          ls -la src-tauri/target/release/bundle/nsis/ 2>/dev/null || echo "NSIS directory not found"
          echo ""
          echo "All bundle directories:"
          ls -la src-tauri/target/release/bundle/ 2>/dev/null || echo "Bundle directory not found"

      - name: Upload Windows installers
        shell: bash
        run: |
          UPLOADED=false

          # Search for all MSI files
          echo "=== Searching for MSI installers ==="
          if [ -d "src-tauri/target/release/bundle/msi" ]; then
            for MSI_FILE in src-tauri/target/release/bundle/msi/*.msi; do
              if [ -f "$MSI_FILE" ]; then
                echo "Uploading MSI: $MSI_FILE"
                gh release upload "${{ github.ref_name }}" "$MSI_FILE" --clobber
                UPLOADED=true
              fi
            done
          else
            echo "MSI directory not found"
          fi

          # Search for all NSIS exe files
          echo "=== Searching for NSIS installers ==="
          if [ -d "src-tauri/target/release/bundle/nsis" ]; then
            for NSIS_FILE in src-tauri/target/release/bundle/nsis/*.exe; do
              if [ -f "$NSIS_FILE" ]; then
                echo "Uploading NSIS: $NSIS_FILE"
                gh release upload "${{ github.ref_name }}" "$NSIS_FILE" --clobber
                UPLOADED=true
              fi
            done
          else
            echo "NSIS directory not found"
          fi

          if [ "$UPLOADED" = false ]; then
            echo "‚ùå ERROR: No Windows installer files found!"
            echo "Build may have failed or produced no installer packages."
            exit 1
          else
            echo "‚úÖ Successfully uploaded Windows installer(s)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-linux:
    needs: [verify-version, create-release]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libssl-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libwebkit2gtk-4.1-dev \
            libglib2.0-dev \
            libfuse-dev \
            libxdo-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev

      - name: Install dependencies
        run: npm ci

      - name: Build Tauri app
        run: npm run tauri:build

      - name: Find and upload AppImage
        shell: bash
        run: |
          APPIMAGE_FILE=$(find src-tauri/target/release/bundle/appimage -name "*.AppImage" -type f | head -n 1)
          DEB_FILE=$(find src-tauri/target/release/bundle/deb -name "*.deb" -type f | head -n 1)

          if [ -f "$APPIMAGE_FILE" ]; then
            echo "Found AppImage: $APPIMAGE_FILE"
            gh release upload ${{ github.ref_name }} "$APPIMAGE_FILE" --clobber
          fi

          if [ -f "$DEB_FILE" ]; then
            echo "Found DEB: $DEB_FILE"
            gh release upload ${{ github.ref_name }} "$DEB_FILE" --clobber
          fi

          if [ ! -f "$APPIMAGE_FILE" ] && [ ! -f "$DEB_FILE" ]; then
            echo "No Linux packages found"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish-release:
    needs: [create-release, build-macos, build-windows, build-linux]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Publish release
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: ${{ needs.create-release.outputs.release_id }},
              draft: false
            })
